# [2023.01.26] struct와 class와 enum의 차이를 설명하시오

오늘은 class, struct, enum 같이 알아보자구!

나는 솔직히 이 개념이 헷갈려.. 왜냐면 값타입, 참조타입의 메모리 구조를 이해하기가 어려웠거든

먼저 클래스부터 들어가보자잉

### 1. Class

클래스의 특징은 참조타입 (call by reference)라는 거야 

클래스를 보면 참조타입의 인스턴스 → Heap 영역에 할당을 시킨다라고 말해도 된다구

아래보면 bibleTeam 인스턴스가 값자체를 가지고 있는것이 아닌 Heap영역의 변수를 참조하고 있다고 보면 되는거야

![스크린샷 2023-01-26 오후 1 56 15](https://user-images.githubusercontent.com/85090866/214761532-4d4a18c1-4970-4c63-8eff-7477b6436093.png)


그러면 증명을 해볼게 얍!

![Untitled 1](https://user-images.githubusercontent.com/85090866/214761065-35c9a6ff-16a3-45a6-bffa-f68f5e650548.png)

아이고 이게 아니라.. 다시한번 얍!

![%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_12 44 14](https://user-images.githubusercontent.com/85090866/214761120-eeed5c51-5652-4f0c-b6e8-b60babcbece6.png)


이게 참조타입의 정확한 증명이야 즉 price, month를 참조하고 있으니까 값이 변경되면 아래 pakaTeam도 변경이 되버리지.. 

또 let으로 해도 상관없겠지? 왜냐구? 내부프로퍼티는 Heap에 변수(var) 저장이 되어있고 Stack에서만 let으로 선언하는 거니까 :) 

두번째 클래스는 **상속**이 가능해 (부럽다 엘런편)

![%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_12 54 36](https://user-images.githubusercontent.com/85090866/214761139-07f24dc9-4d94-413d-b03c-95ab14e84e65.png)

세번째 이니셜라이저가 꼭 필요하다는 거야 

이니셜라이저는 선언한 모든프로퍼티에 기본값을 할당해주는 역할이지 초기값!!!

### 2. Struct

이제 여기서 질문 클래스는 참조타입이지? 그럼 구조체는 !? 

그래 값 타입이야.. 딱봐도 뭔가 참조보다는 단순해보이니까

 

위에 코드에 class → struct 로 바꿔볼게 

![%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1 06 00](https://user-images.githubusercontent.com/85090866/214761159-cf126ff2-3d0e-4f28-a969-41d3b1c19b01.png)


..? 아니.. 글자 몇개 바꿨는데 결과가 달라졌네 즉 이게 값타입과 참조타입의 차이라는 거야

메모리 구조로 봐보자!

![스크린샷 2023-01-26 오후 1 56 56](https://user-images.githubusercontent.com/85090866/214761615-390998a4-4f50-4779-8c31-1cd4c4a38b73.png)


와.. 그냥 값을 복사하는 구나 힙을 사용하지 않는구나 

그럼 힙에 흩어져있는 참조하는 것보다 훨씬 빠르겠구나! (끄덕끄덕)

그럼 아까 참조와 다르게 우리가 le으로 선언하면(?) 당연히 값이 바뀌지 않는것도 이해 오키?

그렇질문 상속은 가능할까? 불가능해 .. 그냥 불가능해 외워버려

### Enum(이늄)

이거 왜 이넘아니고.. 이늄이지? 여튼 레츠기릿

간단하기 Enum은 연관된 값들을 한 곳에 묶어 놓은 값타입이다. 뭐라고? 값타입이라고

자 여기서 중요한건 타입이기에 타입선언이 가능하겠죠?

바로 코드를 보자

![%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1 25 26](https://user-images.githubusercontent.com/85090866/214761194-aff45b3b-65ca-4129-9b52-b1420937b1f0.png)
 

case 자체가 고유값이라고 생각하면되구 이렇게도 쌉가능 하지

![%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1 30 22](https://user-images.githubusercontent.com/85090866/214761216-52edad42-099f-4b0b-8237-2d8bee25a9d4.png)

이렇게 점문법으로도 가능하지

![%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1 31 08](https://user-images.githubusercontent.com/85090866/214761240-901f5b97-7674-4a44-99f1-300294c1544d.png)


다음은 원시값에 대해 이야기 해보자 진짜 영어로 Raw Value야!

단! 원시값 지정은 Number Type, Character Type, String Type만 가능해 

![%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1 37 17](https://user-images.githubusercontent.com/85090866/214761258-af65b106-bfa7-4650-b8d6-ec3d6aa9b9e0.png)

원시값을 지정해주면 case는 바로 이전 case → Raw Value +1 이 된다구 

그렇지만 Int형 String형을 빼고는 모두 원시값을 지정해줘야만 가능하다는 점 기억해주면 좋겠어.. ㅠㅠ

### 최종 정리

- 공통점
    - 프로퍼티와 메소드를 사용해 구조화된 데이터 기능을 가진다
    - 새로운 사용자 지정타입을 만든다
    - 초기화를 정의해 초기상태 설정이 가능하다
    - 확장(extention)이 가능하다
    - 프로퍼티 값에 접근할때 점문법(.)을 사용한다
    - 프로토콜 사용이 가능하다
    - 타입을 정의하기에 UpperCamelCase를 사용한다
- 차이점

|  | 구조체 | 클래스 |
| --- | --- | --- |
| 상속 | 불가능 | 가능 |
| 메모리 | 스택 (빠름) | 힙  |
| 타입 | 값 타입 | 참조타입 |
| 복사 | 복사본  | 원본의 메모리 주소 |

### 구조체를 쓰는 경우

1. 서로 연관된 몇 개의 기본 데이터 타입을 캡슐화하여 묶는 것이 목적일 때
2. 캡슐화된 데이터에 상속이 필요하지 않을 때
3. 값이 복사되는 것이 합리적일 때
4. 캡슐화 된 원본 데이터를 보존해야 할 때
